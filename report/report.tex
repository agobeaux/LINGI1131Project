\documentclass[12pt,journal]{IEEEtran}

\usepackage{cite}
\usepackage{mathtools}
\usepackage{array}
\usepackage{dblfloatfix}
\usepackage{hyperref}
\usepackage[T1]{fontenc}
\usepackage{inconsolata}
\usepackage{siunitx}

\usepackage{color}
\definecolor{bluekeywords}{rgb}{0.13,0.13,1}
\definecolor{greencomments}{rgb}{0,0.5,0}
\definecolor{redstrings}{rgb}{0.9,0,0}

\usepackage{listings}
\lstset{language=Oz,
	showspaces=false,
	showtabs=false,
	breaklines=true,
	showstringspaces=false,
	breakatwhitespace=true,
	escapeinside={(*@}{@*)},
	commentstyle=\color{greencomments},
	keywordstyle=\color{bluekeywords},
	stringstyle=\color{redstrings},
	basicstyle=\ttfamily
}


\hyphenation{op-tical net-works semi-conduc-tor}

\newcommand{\ntt}{\normalfont\ttfamily}
\newcommand{\fn}[1]{{\protect\ntt#1}}

\begin{document}
\title{Ozploding bozmbs -- Bomberman in Oz}
\author{Alexandre Gobeaux and Gilles Peiffer%
\IEEEcompsocitemizethanks{\IEEEcompsocthanksitem Alexandre Gobeaux -- 42191600\protect\\
E-mail: \href{mailto:alexandre.gobeaux@student.uclouvain.be}{alexandre.gobeaux@student.uclouvain.be}%
\IEEEcompsocthanksitem Gilles Peiffer -- 24321600 \protect\\
E-mail: \href{mailto:gilles.peiffer@student.uclouvain.be}{gilles.peiffer@student.uclouvain.be}}
}

\markboth{Ozploding bozmbs -- Bomberman in Oz}%
{Alexandre Gobeaux and Gilles Peiffer}


\IEEEtitleabstractindextext{%
\begin{abstract}
In this paper, the methodology and design choices behind our implementation of the Bomberman game in Oz are given.
Both the turn-by-turn part of the game controller as its simultaneous part are explained, and an attempt is made to clarify why the authors took certain decisions with regards to how the final product works.
On top of that, an algorithm was implemented in order to control the players' moves, reacting to various messages it receives containing either requests or information about the game.
This was done in at various levels of complexity, building increasingly efficient players.
On top of the mandatory parts of the project, various supplementary features and embellishments are also included in the implementation.

In order to validate our product, interoperability tests were also carried out with both the reference player and other teams' players.
This paper presents a brief summary of the results of these tests.
\end{abstract}
}


\maketitle

\IEEEdisplaynontitleabstractindextext

\section{Introduction}

\IEEEPARstart{B}{omberman} is a famous game.

\section{Controller structure}

\subsection{Turn-by-turn controller}

\subsection{Simultaneous controller}

\section{Player structure}

\subsection{General structure}
\IEEEPARstart{I}{n} order to play the game intelligently, players have to store all relevant information about a game; in order to do this in a clean manner, the authors opted to use record structures, which can easily be modified with the \lstinline|AdjoinList| function.
These records change vary for more advanced players, as they need to store more data about the game in order to make use of their intelligent strategies, but the records always contain at least the following fields:
\begin{itemize}
	\item \lstinline|id|: ID of the player;
	\item \lstinline|state|: state of the player;
	\item \lstinline|lives|: number of remaining lives;
	\item \lstinline|pos|: current position;
	\item \lstinline|sppos|: assigned spawn position;
	\item \lstinline|bombs|: number of bombs owned;
	\item \lstinline|map|: map of the game;
	\item \lstinline|score|: number of points.
\end{itemize}

Players have to respond to different messages they can get from the controller, in the form of a stream of instructions.
In order to handle each of these messages, multiple so-called ``handler functions'' were created, one for each possible instruction.
Most of the messages that a player can receive in its stream are relatively straightforward; in this paper, only the most important instruction, \lstinline|doaction(ID Action)| is explained.

The \lstinline|doaction(ID Action)| message asks the player for its ID and its next action (place a bomb at its current location or move to a neighbouring location).
Multiple players were implemented, with the difference between them lying mainly in the way the ``optimal'' action is computed.
These differences are explained in Section~\ref{sec:playerai}.

\subsection{Decision algorithms}
\label{sec:playerai}
\subsubsection{Basic player}
In our basic random player, \fn{Player001Kardashian.ozf}, the decision algorithm looks like this:
\begin{itemize}
	\item If the player has no bombs left, move to a random neighbour with uniform probability over the acceptable moves.
	\item If the player has bombs left, the player has a \SI{10}{\percent} chance to drop a bomb, and a \SI{90}{\percent} chance to move to a randomly chosen acceptable neighbour.
\end{itemize}

This strategy is not very efficient: the player does not avoid bombs, and does not hunt for points.

\subsubsection{Advanced player}
Our next player, \fn{Player001Tao.ozf}, is slightly more advanced; its decision algorithm tries to avoid standing in dangerous areas, i.e. too close to bombs.
This means that the advanced player has to keep track of where bombs are located.
In order to do this, one must simply add an argument to the \lstinline|summary| record: \lstinline|bomblist|, which stores a list of bombs that are currently on the map.
When the player has to determine its next action, it uses the following algorithm:
\begin{itemize}
	\item If the player has no bombs left, move to the least dangerous acceptable neighbour, where the danger rating of a tile is found by initialising it to zero, and then adding points if the tile is in the blast radius of a bomb (taking into account that walls and boxes stop fire from spreading, as well as the distance from the bomb).
	\item If the player has bombs left, the player has a \SI{10}{\percent} chance to drop a bomb, and a \SI{90}{\percent} chance to move according to the algorithm above.
\end{itemize}

This strategy is more successful than the basic player, and most of the time manages to avoid bombs.
It does not however hunt for points or bonuses, and can make wrong choices when trying to avoid bombs (forcing itself into a dead end, for example).

\subsubsection{Intelligent player}
The intelligent player, \fn{Player001Turing.ozf}, builds further on what the advanced player does, by adding the ability to intelligently search for points and bonuses, with the latter being preferred in most cases.
In order to track where points and bonuses are located, one has to take care of treating the \lstinline|boxRemoved(Pos)| messages.
The algorithm is the following:
\begin{itemize}
	\item If the player has no bombs left, move to the least dangerous acceptable neighbour, where the danger rating of a tile is found by initialising it to zero, and then adding points if the tile is in the blast radius of a bomb (taking into account that walls and boxes stop fire from spreading, as well as the distance from the bomb).
	If multiple neighbours are equally safe, run a breadth-first search for points and one for bonuses.
	If possible, the player tries to go for a bonus first, given that the distance to the next bonus is not too big compared to the distance to the next point\footnote{Heuristically, we found a ratio of \(3\) to work fairly well.}.
	If there is a point target and no bonuses, the player moves towards it on the shortest path.
	Finally, if there are no special targets, the player chooses a random neighbour from the safe options.
	\item If the player has bombs left, it tries to place a bomb given that it is next to a box (in order to lay bare its content).
	Otherwise, it moves towards a position according to the algorithm above.
\end{itemize}

This strategy works very well, and consistently came out as one of the top AIs when competing with other teams.

\section{Interoperability}
In order to validate our implementation, we carried out interoperability tests with various groups.
These tests helped us to identify misunderstandings in the project specification, as well as find some tricky bugs.

\subsection{Group 55 -- Mulders, Semerikova}
While trying for interoperability with this group, we were reminded that our player is not allowed to place two bombs on the same tile.
In order to fix this mistake, we had to rework the way the list of bombs is kept.
Thinking about this also helped us to solve another issue we had when playing simultaneously; with the new design, our implementation was no longer specifically tailored to a certain game mode, i.e. turn-by-turn.
Another error we found is that the advanced players did not always bind an ID when returning an Action.
Since our \fn{Main.ozf} was very robust and did not actually need these values as they were being kept track of, the error never showed on our own computers.

Another issue we ran into while testing our players with this group was that after some rounds, our player would stop planting bombs, despite being under the right circumstances to do so.
When investigating the code, this came down to a mismatch in specifications between the initialisation of the list of bombs and the \lstinline|case| statement trying to access it.


\section{Extensions and optional parts}
Some of the proposed extensions and improvements were implemented:
\begin{itemize}
	\item As explained in Section~\ref{sec:playerai}, one of our players,
	\fn{Player001Turing.ozf}, uses a fairly advanced algorithm to determine its next action.
	\item The GUI has been embellished to resemble the user interface of the Minecraft game.
	\item The synchronization between the GUI and the controller has been automated, to avoid the game starting while the GUI is still loading.
\end{itemize}

\section{Conclusion}
Working on this project has helped us to better understand

\begin{thebibliography}{1}

\bibitem{IEEEhowto:kopka}
H.~Kopka and P.~W. Daly, \emph{A Guide to \LaTeX}, 3rd~ed.\hskip 1em plus
  0.5em minus 0.4em\relax Harlow, England: Addison-Wesley, 1999.

\end{thebibliography}


\end{document}


